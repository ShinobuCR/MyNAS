
@app.route('/api/ffmpeg')
def ffmpeg_request():
    '''
    这里假设先启动ffmpeg转码ts 进程异步启动，后续处理关闭等问题
    然后返回hls流
    '''
    decode_dir='/tmp/decode'
    os.popen('ffmpeg -i "/Users/liuwei/SynologyDrive/MMD/【av14182836】完整3人桃源恋歌.mp4" -c copy -f hls -segment_list playlist.m3u8 -segment_time 2 cat_output%03d.ts ')
    return send_from_directory(directory='/tmp/decode/output', filename='index.f4m',mimetype="application/x-mpegURL")

# @app.after_request
# # 告訴瀏覽器不要cache
# def add_header(response):
#     response.headers['X-UA-Compatible'] = 'IE=Edge,chrome=1'
#     response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
#     response.headers['Pragma'] = 'no-cache'
#     response.headers['Expires'] = '0'
#     return response

# @app.route('api/video/<string:file_name>')
# def stream(fil/e_name):
    # 提供串流影片
    # ./video是影片放的位置，就是m3u8和他的ts們的所在地
    # os.popen('ffmpeg -i "/Users/liuwei/SynologyDrive/MMD/【av14182836】完整3人桃源恋歌.mp4" -c copy -f hls /tmp/decode/index.m3u8  ')
    # response.headers['X-UA-Compatible'] = 'IE=Edge,chrome=1'
    # response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    # response.headers['Pragma'] = 'no-cache'
    # response.headers['Expires'] = '0'
    # return send_from_directory(directory='/tmp/decode', filename=file_name)



'''
编码过程为：
1 对接收到的请求：
    .m3u8请求的话，如果对应文件不存在，则从头转码

'''

@app.route("/api/video/hls/<int:video_id>.m3u8")
def stream_hls(video_id):
    '''
    这里主要是返回hls目录
    路径格式为 /tmp/hls/<video id>
    每个片段10s
    '''
    index_m3u8="#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-TARGETDURATION:10\n#EXT-X-MEDIA-SEQUENCE:0\n"
    video=get_file(video_id)
    ffprobe_command = f'{ffprobe_path}  -print_format json -v error -show_entries format=duration  "{video["path"]}"'
    result = os.popen(ffprobe_command).read()
    if result:
        video_info = json.loads(result)
        video_len=float(video_info['format']['duration'])
        for i in range(int(video_len/10)):
            index_m3u8+="#EXTINF:10.000000,\n%s/%s.ts\n" % (video_id,i)
        index_m3u8+="#EXTINF:%s,\n%s/%s.ts\n" % (video_len%10,video_id,int(video_len/10))
    index_m3u8+="#EXT-X-ENDLIST\n"

    
    response = make_response(index_m3u8)
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Credentials'] = 'true'
    response.headers['Content-Type'] = 'application/x-mpegURL'
    response.headers['X-UA-Compatible'] = 'IE=Edge,chrome=1'
    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

running_ffmpeg=None

@app.route("/api/video/hls/<int:video_id>/<int:hls_index>.ts")
def stream_hls_ts(video_id,hls_index):
    '''
    
    统一重新编码为h264，acc格式
    对于ts文件已经存在的，直接返回
    如果ts文件不存在
        1. 如果当前正在运行ffmpeg，杀掉当前已经存在的ffmpeg进程
        2. 从指定index计算开始时间，开始转码 
    '''

    video=get_file(video_id)
    # cn = hashlib.md5(f"{video_id}.{hls_index}.ts".encode()).hexdigest()
    base_dir=PHOTO_CATCH+f"/decode/{video_id}/"
    # ffmpeg_command=ffmpeg_path+f' -ss {hls_index*10} -t 10 -y -i "{video["path"]}" -c:v libx264 -c:a aac -vcodec h264_videotoolbox  -bsf:v h264_mp4toannexb -r 30 {PHOTO_CATCH}/{cn}.ts'
    if os.path.exists(base_dir+"/"+f"index{hls_index}.ts"):
        return send_from_directory(base_dir,f"index{hls_index}.ts")
    else:

        if running_ffmpeg is not None:
            if running_ffmpeg.poll() is None:
                print("kill ffmpeg ",running_ffmpeg.pid)
                running_ffmpeg.kill()
        ffmpeg_command=ffmpeg_path+f' -y -i "{video["path"]}" -c:v libx264 -c:a aac -vcodec h264_videotoolbox  -f hls  -bsf:v h264_mp4toannexb -r 30 -hls_list_size 1000000 -hls_time 10 {base_dir}/index.m3u8'
        print(ffmpeg_command)
        popen=subprocess.Popen(ffmpeg_command)
        running_ffmpeg['popen']=popen
    